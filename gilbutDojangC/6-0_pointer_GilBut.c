#include <stdio.h>

//코딩도장 길벗 IT전문서
// https://dojang.io/mod/page/view.php?id=275 
int main(void)
{
    // 포인터(변수) = 메모리 주소.(의 첫 부분을 알려줌)
    // 포인터변수를 선언할때는 data type(자료형)을 알려주고 asterisk(*)를 붙이는 방식을 사용.
    // 만약 변수가 int형이면 이 변수의 메모리주소를 저장하는 포인터는 int포인터여야 한다.
    
    // int * 는 영어로 pointer to int 라고 읽음.
    // int를 가르키는 포인터라는 뜻.

    // 32비트 포인터의 크기는 32비트(8바이트)
    // 범위는 16진수 8자리까지이다.
    // 0x00000000 ~ 0xFFFFFFFF
    // 64비트 포인터의 크기는 64비트(16바이트)
    // 범위는 16진수 16자리까지이다.
    // 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF



    int *numPtr; // *로 포인터 변수 선언
    int num1 = 10; // num1을 선언하고 10을 할당
    numPtr = &num1; // &는 주소연산자로 num1의 주소를 구해서 할당
    //위에서 numPtr = pointer to int == &num1 = adress of int
    //(둘은 자료형이 같아서 일치함)
    // 역참조연산자
    
    printf("num1 %d\n", num1);
    printf("&num1 %d\n", &num1);
    printf("numPtr %d\n", numPtr); //여기서 *는 역참조 연산자
    printf("*numPtr %d\n", *numPtr);
    
    // 포인터변수 앞에 *을 붙이면 포인터변수에 저장된 메모리 주소로 가서 값을 가져옴.
    // 포인터변수는 변수의 주소만 가르키고
    // 역참조 연산자는 변수의 주소에 접근해서 변수의 값을 가져옵니다. 
    
    // 포인터를 사용할때도 *를 사용하고 역참조를 사용할때도 *를 사용한다.
    // 포인터를 선언할 때 *은 "이 변수가 포인터다" 라고 알려줌.
    // 포인터에 사용할 때 *은 "포인터의 메모리 주소를 역참조하겠다"라는 뜻이다.

    //*포인터 = 값;
    //////////////////정리//////////////////
    // 변수 : 메모리주소를 몰라도 값을 저장하거나 가져올 수 있다.
    // 주소연산자(&) : 변수의 메모리주소를 구한다.
    // 역참조연산자(*) : 메모리에 저장된 값에 접근할 수 있다. 즉, 메모리 주소에 접근하여 값을 가져오고 저장한다.
    // 포인터(변수) : 변수의 메모리주소만 가르킨다. 

    // c언어에서 사용되는 모든 자료형(int, char, float, long long..)은
    // 포인터로 만들 수 있다.
    // Q. 근데 포인터 자료형이라고 따로 만들어두면 편할텐데 왜 자료형마다 포인터를 선언하도록 만들었을까요?
    // A. 포인터에 저장되는 메모리 주소값은 정수형으로 같다. 하지만 선언하는 자료형에따라서 메모리에 접근하는 방법이 달라짐.
    // unit 58 자료형 변환하기에서 자세하게 설명

    // void * 포인터이름;
    int num2 = 10;
    char c2 = 'a';
    int *numPtr2 = &num2;
    char *cPtr2 = &c2;

    void *ptr;

    ptr = numPtr2;
    printf("%d\n", ptr);
    // printf("%d\n", *ptr); // 보이드 키워드로는 변수를 선언할 수 없음.
    // 역참조를 사용할수도 없는 보이드 포인터를 왜 사용하나?
    // ex) 함수에서 다양한 자료형을 받아들일때, 함수의 반환포인터를 다양한 자료형으로 된 포인터에 저장할때, 자료형을 숨기고 싶을때 사용
    ptr = cPtr2;
    printf("%d\n", ptr);
    
    numPtr2 = ptr;
    printf("%d\n", ptr);
    
    cPtr2 = ptr;
    printf("%d\n", ptr);
    
    // 자료형이 다른 포인터끼리 메모리주소를 저장하면 컴파일 경고가 뜨는데
    // 하지만 void포인터는 자료형이 정해지지 않은 특성이 있어
    // 어떤 자료형으로 된 포인터든 모두 저장할 수 있음.
    // 그래서 보이드 포인터는 범용 포인터라고 부름
    // 보이드포인터는 직접 자료형을 변환하지 않아도 암시적으로 자료형이 변환되는 방식임.

    
/////////////////////////////////////////////////////////

    return 0;
}